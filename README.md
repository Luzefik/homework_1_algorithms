Основна мета — розробити та порівняти три різні реалізації структури даних в пам'яті для ефективного зберігання та обробки бази студентів. Проводиться бенчмарк трьох варіантів операцій (за варіантом V5) та двох алгоритмів сортування (за варіантом S1).

## Реалізований варіант (V5, S1)

### Задача II (Варіант V5)
Програма підтримує та вимірює продуктивність трьох основних операцій у співвідношенні A:B:C:
1.  **`get_top_100()`**: Повернути 100 студентів з найвищим рейтингом.
2.  **`set_grade_by_email()`**: Встановити рейтинг студенту за його електронною поштою (m_email).
3.  **`get_top_group()`**: Знайти групу, в якій найбільший середній рейтинг студентів.

### Задача III (Варіант S1)
Програма порівнює продуктивність двох алгоритмів сортування та зберігає результат у файл.
1.  **`std::sort`**: Сортування за `m_email` з використанням стандартної функції.
2.  **`QuickSort`**: Власноруч реалізований QuickSort для сортування за `m_email`.

## Вимоги

Для збірки та запуску проєкту необхідні:
* **CMake**: версія 3.20 або новіша
* **Компілятор C++**: з підтримкою C++17 (наприклад, GCC, Clang, MSVC)

## Збірка та запуск

Проєкт використовує CMake для керування збіркою.

1.  Клонуйте репозиторій (якщо потрібно) та перейдіть у його директорію.

2.  Створіть директорію для збірки та перейдіть у неї:
    ```bash
    mkdir build && cd build
    ```

3.  Згенеруйте файли збірки:
    ```bash
    cmake ..
    ```

4.  Скомпілюйте проєкт:
    ```bash
    make
    ```
    *Примітка: У `CMakeLists.txt` налаштовано два виконувані файли: `homework_1` (основний) та `run_all` (допоміжний для запуску всіх бенчмарків).*

5.  Запустіть основну програму:
    * **Важливо:** Програма очікує файл `students.csv` у кореневій директорії проєкту (поруч з `src/`, а не в `build/`).
    * Запускати бінарний файл рекомендується з кореневої директорії:
    ```bash
    # Переконайтесь, що ви в кореневій папці проєкту
    ./build/homework_1
    ```

6.  **Результати:**
    * Програма виведе детальні результати бенчмарків (час ініціалізації, використана пам'ять, операцій/сек) у консоль.
    * Програма згенерує файл `sorted_by_email.csv` у директорії `cmake-build-debug` (або `build`) з відсортованими даними.

    Опис реалізацій (Задача ІІ)

Для порівняльного аналізу було реалізовано три різні підходи до організації даних, що успадковують `IDataStructure`.

#### 1. `DataStructureV1` (Оптимальний)
* **`get_top_100`**: Використовує `std::vector<student*>` (`sorted_rating`), який сортується один раз при ініціалізації (`quicksort_grade`). Час доступу $O(1)$ (для перших 100 елементів).
* **`set_grade_by_email`**: Використовує `std::unordered_map<string, student*>` (`students_emails`) для миттєвого ($O(1)$ в середньому) доступу до студента. Після оновлення рейтингу, позиція елемента у `sorted_rating` коригується (найгірший випадок $O(N)$).
* **`get_top_group`**: Використовує `std::unordered_map<string, pair<float, int>>` (`students_groups`) для зберігання суми рейтингів та кількості. Час $O(\text{кількість груп})$.

#### 2. `DataStructureV2` (Альтернативний, на базі дерев)
* **`get_top_100`**: Використовує `std::multiset<student*, RatingComparator>` (збалансоване червоно-чорне дерево), яке автоматично підтримує студентів у посортованому порядку. Час доступу $O(\log N + 100)$.
* **`set_grade_by_email`**: Використовує `std::map<string, student*>` для доступу за email ($O(\log N)$). Оновлення рейтингу вимагає видалення ($O(\log N)$) та вставки ($O(\log N)$) елемента у `multiset`.
* **`get_top_group`**: Використовує `std::map` (аналогічно до V1, але на дереві).

#### 3. `DataStructureV3` (Наївний, базовий)
* **`get_top_100`**: Зберігає все в одному `std::vector<student*>`. При кожному виклику виконує часткове сортування `std::partial_sort` ($O(N \log 100)$).
* **`set_grade_by_email`**: Виконує лінійний пошук по `std::vector` ($O(N)$) для знаходження студента.
* **`get_top_group`**: Виконує повний прохід по `std::vector` ($O(N)$), агрегуючи дані в тимчасовий `std::unordered_map`.