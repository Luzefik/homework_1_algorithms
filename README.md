Основна мета — розробити та порівняти три різні реалізації структури даних в пам'яті для ефективного зберігання та обробки бази студентів. Проводиться бенчмарк трьох варіантів операцій (за варіантом V5) та двох алгоритмів сортування (за варіантом S1).

## Реалізований варіант (V5, S1)

### Задача II (Варіант V5)
Програма підтримує та вимірює продуктивність трьох основних операцій у співвідношенні A:B:C:
1.  **`get_top_100()`**: Повернути 100 студентів з найвищим рейтингом.
2.  **`set_grade_by_email()`**: Встановити рейтинг студенту за його електронною поштою (m_email).
3.  **`get_top_group()`**: Знайти групу, в якій найбільший середній рейтинг студентів.

### Задача III (Варіант S1)
Програма порівнює продуктивність двох алгоритмів сортування та зберігає результат у файл.
1.  **`std::sort`**: Сортування за `m_email` з використанням стандартної функції.
2.  **`QuickSort`**: Власноруч реалізований QuickSort для сортування за `m_email`.

## Вимоги

Для збірки та запуску проєкту необхідні:
* **CMake**: версія 3.20 або новіша
* **Компілятор C++**: з підтримкою C++17

## Збірка та запуск

Проєкт використовує CMake для керування збіркою.

1.  Клонуйте репозиторій (якщо потрібно) та перейдіть у його директорію.

2. виконайте ці команди при першому запуску
```
chmod +x run_simple.sh
```
3. Потім вам достатньо запустити тільки цю команду
```./run_simple.sh   ```

5.  Запустіть основну програму:
    * **Важливо:** Програма очікує файл `students.csv` у кореневій директорії проєкту (поруч з `src/`, а не в `build/`).
    * Запускати бінарний файл рекомендується з кореневої директорії:


6.  **Результати:**
    * Програма виведе детальні результати бенчмарків (час ініціалізації, використана пам'ять, операцій/сек) у консоль.
    * Програма згенерує файл `sorted_by_email.csv` у директорії `cmake-build-debug` (або `build`) з відсортованими даними.

    Опис реалізацій (Задача ІІ)

Для порівняльного аналізу було реалізовано три різні підходи до організації даних, що успадковують `IDataStructure`.

#### 1. `DataStructureV1` (Оптимальний)
* **`get_top_100`**: Використовує `std::vector<student*>` (`sorted_rating`), який сортується один раз при ініціалізації (`quicksort_grade`). Час доступу $O(1)$ (для перших 100 елементів).
* **`set_grade_by_email`**: Використовує `std::unordered_map<string, student*>` (`students_emails`) для миттєвого ($O(1)$ в середньому) доступу до студента. Після оновлення рейтингу, позиція елемента у `sorted_rating` коригується (найгірший випадок $O(N)$).
* **`get_top_group`**: Використовує `std::unordered_map<string, pair<float, int>>` (`students_groups`) для зберігання суми рейтингів та кількості. Час $O(\text{кількість груп})$.

#### 2. `DataStructureV2` (Альтернативний, на базі дерев)
* **`get_top_100`**: Використовує `std::multiset<student*, RatingComparator>` (збалансоване червоно-чорне дерево), яке автоматично підтримує студентів у посортованому порядку. Час доступу $O(\log N + 100)$.
* **`set_grade_by_email`**: Використовує `std::map<string, student*>` для доступу за email ($O(\log N)$). Оновлення рейтингу вимагає видалення ($O(\log N)$) та вставки ($O(\log N)$) елемента у `multiset`.
* **`get_top_group`**: Використовує `std::map` (аналогічно до V1, але на дереві).

#### 3. `DataStructureV3` (Наївний, базовий)
* **`get_top_100`**: Зберігає все в одному `std::vector<student*>`. При кожному виклику виконує часткове сортування `std::partial_sort` ($O(N \log 100)$).
* **`set_grade_by_email`**: Виконує лінійний пошук по `std::vector` ($O(N)$) для знаходження студента.
* **`get_top_group`**: Виконує повний прохід по `std::vector` ($O(N)$), агрегуючи дані в тимчасовий `std::unordered_map`.

#### Результати
<img width="800" height="500" alt="sorting_times" src="https://github.com/user-attachments/assets/bd7e8fd8-9dc4-48f3-ab9a-338d5739016d" />
<img width="800" height="500" alt="ops_throughput" src="https://github.com/user-attachments/assets/e8666da7-f25d-43a3-b00a-9637bc867e40" />
<img width="800" height="500" alt="mem_usage" src="https://github.com/user-attachments/assets/75afbbbe-0ac2-4e58-ac15-6f61e8b5e856" />
<img width="800" height="500" alt="init_times" src="https://github.com/user-attachments/assets/c2dcf87d-66bc-4151-952b-9b55c89c238e" />


Висновки по графіках
--------------------

- `sorting_times.png` — час сортування (std::sort vs quick_sort):
    - std::sort та реалізація quick_sort дають порівнянні результати.
    - На великих масивах `std::sort` трохи швидше у вимірах (різниця кількох мс при 100k), але обидва коректні.

- `ops_throughput.png` — операцій/сек від розміру:
    - Загальна тенденція: для всіх реалізацій пропускна здатність падає зі збільшенням розміру набору даних.
    - V1 показав хорошу швидкість на найменшому наборі (size=100), але при великих розмірах програє V2/V3.
    - V3 (unordered_set) дає найкращу або близьку до найкращої пропускної здатності на великих розмірах.

- `mem_usage.png` — оцінка використаної пам'яті:
    - Усі три реалізації використовують подібний обсяг пам'яті на тих самих розмірах.
    - Різниці невеликі (порядок сотень тисяч байт) — немає очевидного лідера з точки зору пам'яті.

- `init_times.png` — час ініціалізації структури (init_ms):
    - Час ініціалізації зростає з розміром даних (очікувано).
    - V2 (map+multiset) має помітно більший початковий оверхед на великих розмірах у порівнянні з V1/V3.

Коротко: V3 дає найкращий баланс швидкості операцій при великих розмірах, V2 має більший час ініціалізації, пам'ять у всіх реалізацій близька.


